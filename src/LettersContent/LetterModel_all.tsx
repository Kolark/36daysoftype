/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { useEffect, useRef } from "react";
import { useGLTF } from "@react-three/drei";
import { GLTF } from "three/examples/jsm/loaders/GLTFLoader";

import { DoubleSide, ShaderMaterial } from "three";

import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
import { useFrame, useThree } from "@react-three/fiber";

type GLTFResult = GLTF & {
    nodes: {};
    materials: {};
};

type ModelProps = {
    groups: JSX.IntrinsicElements["group"];
    vertexShader: string;
    fragmentShader: string;
    model: string;
};

export default function Model(props: ModelProps) {
    //Main hooks
    useGLTF.preload("/36daysoftype/gltfCompressed/" + props.model);
    const group  = useRef<THREE.Group>();
    const group2 = useRef<THREE.Group>();
    const { nodes, materials } = useGLTF("/36daysoftype/gltfCompressed/" + props.model) as GLTFResult;

    const myRef = useRef();
    const myRef2 = useRef([0, 0]);

    //Basic Material
    const shaderMaterial = new ShaderMaterial({
        uniforms: { time: { value: 0 } },
        vertexShader: props.vertexShader,
        fragmentShader: props.fragmentShader,
        side: DoubleSide,
        // wireframe:true
    });

    //runs every time the html it's rendered
    useFrame(({ clock }) => {
        // @ts-ignore
        myRef.current.material.uniforms.time.value = clock.getElapsedTime();
        if (group.current) {
            group.current.rotation.x = ((myRef2.current[1]/window.innerHeight) - 0.5) * Math.PI;
            group.current.rotation.y = ((myRef2.current[0]/window.innerWidth) - 0.5)  * Math.PI;
        }
    });

    useEffect(() => { window.addEventListener("mousemove", (e) => { myRef2.current = [e.x, e.y]; }); });
    //Get meshes from nodes
    // @ts-ignore
    const meshes: THREE.Mesh[] = Object.values(nodes).filter( (m) => m.geometry != undefined);

    //first mesh created manually so i can put a ref
    const firstMesh = meshes.shift();
    const meshesElements = meshes.map((m) => { return (<mesh key={m.id} geometry={m.geometry} material={shaderMaterial} />); });

    return (
        <group ref={group} {...props.groups} dispose={null}>
            <group ref={group2} position={[-0.75, -0.75, 0.1]} rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
                <mesh ref={myRef} geometry={firstMesh?.geometry} material={shaderMaterial}/>
                {meshesElements}
            </group>
        </group>
    );
}
